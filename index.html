<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Letter Race 3D</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0b0f14; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #ui { position: fixed; left: 12px; right: 12px; top: 10px; display:flex; justify-content: space-between; pointer-events:none; gap: 10px; }
    .pill { pointer-events:auto; background: rgba(255,255,255,0.10); border: 1px solid rgba(255,255,255,0.14); color:#fff; padding: 10px 12px; border-radius: 14px; display:flex; gap: 10px; align-items:center; user-select:none; }
    #bigLetter { width:46px; height:46px; border-radius: 12px; background: rgba(255,255,255,0.16); display:flex; align-items:center; justify-content:center; font-size:24px; font-weight:900; text-transform: lowercase; }
    #help { position: fixed; left: 12px; right: 12px; bottom: 12px; display:flex; justify-content: space-between; pointer-events:none; gap: 10px; }
    .btn { pointer-events:auto; background: rgba(255,255,255,0.10); border: 1px solid rgba(255,255,255,0.14); color:#fff; padding: 14px 16px; border-radius: 16px; font-weight:800; min-width: 120px; text-align:center; user-select:none; touch-action: manipulation; }
    #overlay { position: fixed; inset:0; display:flex; align-items:center; justify-content:center; background: radial-gradient(ellipse at center, rgba(20,30,45,0.92), rgba(5,7,10,0.96)); color:#fff; z-index: 10; }
    #card { width: min(760px, calc(100% - 24px)); background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.14); border-radius: 18px; padding: 18px; }
    #card h1 { margin: 0 0 8px 0; font-size: 22px; }
    #card p { margin: 6px 0; opacity: 0.92; line-height: 1.35; }
    #card .row { display:flex; gap: 10px; flex-wrap: wrap; margin-top: 12px; }
    #card .row button { background: rgba(255,255,255,0.16); border: 1px solid rgba(255,255,255,0.16); color:#fff; padding: 12px 14px; border-radius: 14px; font-weight: 900; cursor: pointer; }
    #err { margin-top: 10px; padding: 10px 12px; border-radius: 12px; background: rgba(255,80,80,0.12); border: 1px solid rgba(255,80,80,0.18); display:none; white-space: pre-wrap; font-size: 13px; line-height: 1.25; }
    canvas { display:block; }
  </style>
</head>
<body>

<div id="overlay">
  <div id="card">
    <h1>Letter Race 3D</h1>
    <p>Rustig rijden, pak de juiste kleine letter.</p>
    <p>Tik links of rechts om van rijstrook te wisselen.</p>
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="tempoBtn">Tempo: extra rustig</button>
    </div>
    <div id="err"></div>
  </div>
</div>

<div id="ui">
  <div class="pill">
    <div id="bigLetter">b</div>
    <div>Doelletter</div>
  </div>
  <div class="pill">
    <div id="score">Score: 0</div>
  </div>
</div>

<div id="help">
  <div class="btn" id="leftBtn">Links</div>
  <div class="btn" id="rightBtn">Rechts</div>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

  const errBox = document.getElementById("err");
  function showErr(msg) {
    errBox.style.display = "block";
    errBox.textContent = msg;
  }

  window.addEventListener("error", (e) => {
    showErr("Er ging iets mis:\n" + (e?.message || e));
  });

  let scene, camera, renderer;

  let car, lane = 1;
  const laneOffsets = [-2.2, 0, 2.2];
  const carZ = 2.2;

  let baseSpeed = 0.026;
  let speed = baseSpeed;

  const activeLetters = ["b","g","v","m","z","h","k","l","s","w"];
  let target = "b";
  let score = 0;

  let pickups = [];
  let lastSpawnZ = -30;

  const uiBig = document.getElementById("bigLetter");
  const uiScore = document.getElementById("score");
  const overlay = document.getElementById("overlay");

  const rng = () => Math.random();

  function setTarget(l) {
    target = String(l).toLowerCase();
    uiBig.textContent = target;
  }

  function pickNewTarget() {
    setTarget(activeLetters[Math.floor(rng() * activeLetters.length)]);
  }

  function updateScore() {
    uiScore.textContent = "Score: " + score;
  }

  // Weg als glad lint
  let roadMesh = null;
  let roadGeom = null;
  let roadTexture = null;

  const ROAD = {
    width: 12.0,
    length: 320.0,
    segZ: 280,

    phase: 0.0,

    // meestal recht, af en toe een bocht
    turnAmp: 3.4,
    turnPeriod: 240.0,

    // bocht activator, maakt dat bochten soms wel en soms niet “aan” staan
    gatePeriod: 420.0,
    gateSharpness: 10.0,

    // extra kleine variatie, heel subtiel
    microAmp: 0.9,
    microPeriod: 110.0
  };

  function smoothStep(t) { return t * t * (3 - 2 * t); }

  function gateValue(z) {
    // waarde 0 tot 1, meestal 0, af en toe 1
    const x = ((z + ROAD.phase) / ROAD.gatePeriod) * Math.PI * 2;
    const s = (Math.sin(x) + 1) * 0.5; // 0..1
    // maak hem “meer uit dan aan”
    const t = THREE.MathUtils.clamp((s - 0.62) * ROAD.gateSharpness, 0, 1);
    return smoothStep(t);
  }

  function trackOffsetX(z) {
    const gate = gateValue(z);

    const main = ROAD.turnAmp * Math.sin(((z + ROAD.phase) / ROAD.turnPeriod) * Math.PI * 2) * gate;
    const micro = ROAD.microAmp * Math.sin(((z + ROAD.phase) / ROAD.microPeriod) * Math.PI * 2) * (gate * 0.35);

    return main + micro;
  }

  function laneXAtZ(laneIndex, z) {
    return trackOffsetX(z) + laneOffsets[laneIndex];
  }

  function buildRoadTexture() {
    const c = document.createElement("canvas");
    c.width = 512;
    c.height = 1024;
    const ctx = c.getContext("2d");

    ctx.fillStyle = "#111a24";
    ctx.fillRect(0, 0, c.width, c.height);

    // zijranden
    ctx.fillStyle = "rgba(255,255,255,0.25)";
    ctx.fillRect(40, 0, 6, c.height);
    ctx.fillRect(c.width - 46, 0, 6, c.height);

    // midden streep
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    const mid = Math.floor(c.width / 2);
    for (let y = 0; y < c.height; y += 120) ctx.fillRect(mid - 4, y + 20, 8, 60);

    const tex = new THREE.CanvasTexture(c);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(1, 8);
    tex.anisotropy = 8;
    tex.colorSpace = THREE.SRGBColorSpace;
    return tex;
  }

  function cacheRoadBase() {
    const pos = roadGeom.attributes.position;
    const baseX = new Float32Array(pos.count);
    const baseZ = new Float32Array(pos.count);

    for (let i = 0; i < pos.count; i++) {
      const ix = i * 3;
      baseX[i] = pos.array[ix + 0];
      baseZ[i] = pos.array[ix + 2];
    }

    roadGeom.userData.baseX = baseX;
    roadGeom.userData.baseZ = baseZ;
  }

  function bendRoad() {
    const pos = roadGeom.attributes.position;
    const arr = pos.array;

    const baseX = roadGeom.userData.baseX;
    const baseZ = roadGeom.userData.baseZ;

    for (let i = 0; i < pos.count; i++) {
      const ix = i * 3;

      const zLocal = baseZ[i];
      const zWorld = zLocal + roadMesh.position.z;

      const off = trackOffsetX(zWorld);

      arr[ix + 0] = baseX[i] + off;
      arr[ix + 1] = 0; // geen banking, weg blijft vlak
    }

    pos.needsUpdate = true;
    roadGeom.computeVertexNormals();
  }

  function buildRoadMesh() {
    roadTexture = buildRoadTexture();

    roadGeom = new THREE.PlaneGeometry(ROAD.width, ROAD.length, 1, ROAD.segZ);
    roadGeom.rotateX(-Math.PI / 2);

    cacheRoadBase();

    const mat = new THREE.MeshStandardMaterial({
      map: roadTexture,
      roughness: 0.95,
      metalness: 0.0
    });

    roadMesh = new THREE.Mesh(roadGeom, mat);

    // Cruciaal: weg ligt nu onder de auto
    // Range is position.z ± length/2, dus dit moet carZ omvatten
    roadMesh.position.set(0, 0, -ROAD.length * 0.35);

    scene.add(roadMesh);
    bendRoad();
  }

  // Letters
  function makeTextSprite(letter) {
    const canvas = document.createElement("canvas");
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext("2d");

    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(0,0,256,256);

    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.fillRect(20,20,216,216);

    ctx.font = "900 140px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "white";
    ctx.fillText(String(letter).toLowerCase(), 128, 138);

    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = 8;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(1.25, 1.25, 1);
    return sprite;
  }

  function createPickup(letter, laneIndex, z) {
    const group = new THREE.Group();

    const base = new THREE.Mesh(
      new THREE.BoxGeometry(1.05, 0.7, 1.05),
      new THREE.MeshStandardMaterial({ color: 0x9aa6b2, roughness: 0.45, metalness: 0.18 })
    );
    base.position.y = 0.38;
    group.add(base);

    const sprite = makeTextSprite(letter);
    sprite.position.set(0, 1.05, 0.55);
    group.add(sprite);

    group.position.set(laneXAtZ(laneIndex, z), 0, z);
    group.userData = { letter: String(letter).toLowerCase(), laneIndex, hit: false };

    scene.add(group);
    pickups.push(group);
  }

  function spawnSet() {
    const z = lastSpawnZ - 48 - rng() * 22;
    lastSpawnZ = z;

    const correctLane = Math.floor(rng() * 3);
    createPickup(target, correctLane, z);

    const others = activeLetters.filter(l => l !== target);
    for (let i = 0; i < 3; i++) {
      if (i === correctLane) continue;
      const l = others[Math.floor(rng() * others.length)];
      createPickup(l, i, z);
    }
  }

  function setCarTexture(key) {
    if (!car || !car.userData || !car.userData.plane) return;
    const t = car.userData.tex[key];
    if (!t) return;
    car.userData.plane.material.map = t;
    car.userData.plane.material.needsUpdate = true;
  }

  function setupThree() {
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f14, 12, 220);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setClearColor(0x0b0f14, 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    document.body.appendChild(renderer.domElement);

    // Orthographic camera, maar met juiste framing zodat weg onderin zichtbaar is
    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 12.0;
    camera = new THREE.OrthographicCamera(
      -viewSize * aspect, viewSize * aspect,
      viewSize, -viewSize,
      0.1, 900
    );

    camera.position.set(0, 18, 18);
    camera.lookAt(0, 0.6, -40);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x1b2430, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 1.05);
    dir.position.set(6, 14, 6);
    scene.add(dir);

    buildRoadMesh();

    // Auto textures, met duidelijke foutmelding als ze niet laden
    const texLoader = new THREE.TextureLoader();
    texLoader.setCrossOrigin("anonymous");

    const carTex = {
      straight: texLoader.load(
        "./car_straight.png",
        undefined,
        undefined,
        () => showErr("Kan car_straight.png niet laden. Staat het bestand echt naast index.html, met exact deze naam?")
      ),
      left: texLoader.load(
        "./car_left.png",
        undefined,
        undefined,
        () => showErr("Kan car_left.png niet laden. Controleer bestandsnaam en map.")
      ),
      right: texLoader.load(
        "./car_right.png",
        undefined,
        undefined,
        () => showErr("Kan car_right.png niet laden. Controleer bestandsnaam en map.")
      ),
    };

    for (const k of Object.keys(carTex)) {
      carTex[k].colorSpace = THREE.SRGBColorSpace;
      carTex[k].anisotropy = 8;
    }

    const carGroup = new THREE.Group();

    const carPlaneGeom = new THREE.PlaneGeometry(3.0, 3.0);
    const carPlaneMat = new THREE.MeshBasicMaterial({
      map: carTex.straight,
      transparent: true,
      color: 0xffffff
    });

    const carPlane = new THREE.Mesh(carPlaneGeom, carPlaneMat);
    carPlane.position.set(0, 1.15, 0);
    carPlane.rotation.x = -0.22;
    carGroup.add(carPlane);

    const shadow = new THREE.Mesh(
      new THREE.CircleGeometry(1.05, 26),
      new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.22 })
    );
    shadow.rotation.x = -Math.PI / 2;
    shadow.position.y = 0.02;
    carGroup.add(shadow);

    car = carGroup;
    car.position.set(laneXAtZ(lane, carZ), 0, carZ);
    car.rotation.set(0,0,0); // auto blijft recht
    scene.add(car);

    car.userData = { plane: carPlane, tex: carTex, blinkFrames: 0 };

    setTarget(activeLetters[0]);
    for (let i = 0; i < 3; i++) spawnSet();

    window.addEventListener("resize", onResize);
  }

  function onResize() {
    if (!renderer || !camera) return;

    renderer.setSize(window.innerWidth, window.innerHeight);

    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 12.0;
    camera.left = -viewSize * aspect;
    camera.right = viewSize * aspect;
    camera.top = viewSize;
    camera.bottom = -viewSize;
    camera.updateProjectionMatrix();
  }

  function moveLane(dir) {
    const prev = lane;
    lane = Math.max(0, Math.min(2, lane + dir));
    if (lane === prev) return;

    const key = dir < 0 ? "left" : "right";
    setCarTexture(key);
    car.userData.blinkFrames = 28;
  }

  function checkCollisions() {
    for (const p of pickups) {
      if (p.userData.hit) continue;

      const dz = Math.abs(p.position.z - carZ);
      const dx = Math.abs(p.position.x - car.position.x);

      if (dz < 1.15 && dx < 1.05) {
        p.userData.hit = true;

        if (p.userData.letter === target) {
          score += 1;
          pickNewTarget();
        }
        updateScore();
        scene.remove(p);
      }
    }
    pickups = pickups.filter(p => !p.userData.hit);
  }

  function tick() {
    // snelheid
    speed += (baseSpeed - speed) * 0.06;
    const forward = speed * 10;

    // weg “scrolt” en bochten lopen door, maar meestal recht
    ROAD.phase += forward;

    if (roadTexture) roadTexture.offset.y = (roadTexture.offset.y + forward * 0.006) % 1;
    if (roadGeom && roadMesh) bendRoad();

    // auto alleen naar rijstrook, geen meedraaien
    const desiredX = laneXAtZ(lane, carZ);
    car.position.x += (desiredX - car.position.x) * 0.11;
    car.rotation.set(0,0,0);

    // auto sprite wissel even vasthouden
    if (car.userData.blinkFrames > 0) {
      car.userData.blinkFrames -= 1;
      if (car.userData.blinkFrames === 0) setCarTexture("straight");
    }

    // pickups bewegen en volgen de weg
    for (const p of pickups) {
      p.position.z += forward;
      p.position.x = laneXAtZ(p.userData.laneIndex, p.position.z);

      if (p.position.z > 12) {
        scene.remove(p);
        p.userData.hit = true;
      }
    }
    pickups = pickups.filter(p => !p.userData.hit);

    while (pickups.length < 9) spawnSet();

    checkCollisions();

    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }

  function startGame() {
    setupThree();
    overlay.style.display = "none";
    tick();
  }

  // Controls
  document.getElementById("startBtn").addEventListener("click", startGame);

  document.getElementById("tempoBtn").addEventListener("click", (e) => {
    if (baseSpeed > 0.022) {
      baseSpeed = 0.018;
      e.target.textContent = "Tempo: super rustig";
    } else {
      baseSpeed = 0.026;
      e.target.textContent = "Tempo: extra rustig";
    }
  });

  document.getElementById("leftBtn").addEventListener("pointerdown", () => moveLane(-1));
  document.getElementById("rightBtn").addEventListener("pointerdown", () => moveLane(1));

  window.addEventListener("pointerdown", (e) => {
    const x = e.clientX / window.innerWidth;
    if (x < 0.40) moveLane(-1);
    else if (x > 0.60) moveLane(1);
  }, { passive: true });
</script>
</body>
</html>